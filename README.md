 ### 练手项目
 
 方案一：(深度遍历+递归)已实现
    步骤：①按深度遍历优选压栈 
         ②依次计算子节点取数逻辑 得值之后替换父节点表达式的值 依次弹出
         ③递归调用步骤②
         ④最后得出整个树上的表达式值,构建实例完成
    优点:实现简单,完全线程安全
    缺点：单线程 计算效率不高
 方案二：摘叶子算法
    步骤：①取出底稿树 
         ②记录子节点与父节点的映射关系结构为list,(线程共享数据)只读
         ③遍历得树的叶子节点集合
         ④多线程获取叶子节点取数结果后结合步骤②的映射关系,线程安全修改替换父节点上表达式值
         ⑤摘除叶子节点,原来叶子节点的父节点变为叶子节点
         ⑥重复③到⑤最后得到整个树表达式的计算值
     优点：多线程，利用多核提升效率,把整个树的计算抽象成摘叶子的过程，优先摘最外层的叶子，然后层层递进，直到计算根节点。
     缺点：实现较为复杂 需要关注线程完全问题 每一轮运算依赖上一轮运算速度,当有个别节点已经完成计算，可以计算父节点时此时却需要等待
         
 方案三：计算原子算法
    概念：计算原子 深度为1 只含父节点和它的直接子节点看成是一个计算原子 
         例如a有子节点b和c,c又有子节点d e f;那么abc构成一个计算原子 a为父节点 bc为子节点,
         cdef也是一个计算原子,c为父节点,def为子节点。
    步骤：①取出底稿树
         ②按概念计算原子拆掉整个树得出整个计算原子集合(线程共享数据)    
         ③根据计算原子集合得出树的叶子节点(条件：计算原子中的子节点不在其他计算原子中充当父节点)
         ④开启多线程获取叶子节点取数结果 然后并发修改计算原子集合
         (当某一个计算原子的叶子节点都已计算完成,那么这个计算原子就已完成计算,剔除对应的计算原子，并且修改底稿树上对应表达式的值)
         ⑤经过一轮计算后，计算原子结合剩下的也都是未完成计算原子,即计算原子的子节点未全部完成的计算原子集合
         ⑥从计算原子集合中计算得出下一轮叶子节点集合，多线程执行公式取数,即重复步骤③④⑤
         ⑦最后得出整个计算值,底稿实例计算完成.
    优点：多线程取数,互相依赖的节点取数被隔离开来，优点计算没有依赖关系的，然后得出下一轮没有依赖关系的子节点
    缺点：实现较为复杂 需要关注线程安全 每一轮运算依赖上一轮运算速度,当有个别节点已经完成计算，可以计算父节点时此时却需要等待
        
 方案四：最高效率并行处理：待补充            
    
 
    
    

 